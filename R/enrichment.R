# Enrichment tests

#' Set enrichment with Fisher's exact test and random sampling.
#'
#' @description
#' The function tests for enrichment of a vector with elements following some
#' classification system. A good example of enrichment analyses are gene
#' ontology term enrichment. The overlap between elements of a vector of
#' interest with elements of a particular set is investigated by two methods: by
#' Fisher's exact test and random sampling.
#'
#' @details
#' Fisher's exact test operates with a \eqn{2 \times 2} contingency table and
#' checks if an intersection of the vector `x` and the given set is larger than
#' an intersection of all available features and the set. The odds ratio (OR)
#' statistic generated by Fisher's exact test is defined as follows:
#' \deqn{OR = \frac{n_{x \in set} \times n_{all \notin set}}{n_{x \notin set} \times n_{all \in set}}}
#' where \eqn{n_{x \in set}} stands for the number of elements of vector `x`
#' belonging to the set,
#' \eqn{n_{x \notin set}} represents the number of elements of vector `x` not
#' belonging to the set,
#' \eqn{n_{all \in set}} is the number of all available features belonging to
#' the set, and
#' \eqn{n_{all \notin set}} is the number of all available features not
#' belonging to the set.
#' In other words, Fisher's exact test tests for \eqn{OR \neq 1}.
#'
#' Random sampling test compares the number of elements of the particular set
#' in vector x with a large number of random samples draws from all available
#' features. Each of those samples is of equal size as vector `x`. The OR
#' statistic is defined as follows:
#' \deqn{OR = \frac{1}{n_{iter}} \times \sum^{n_{iter}}_i \frac{n_{x \in set}}{n_{sample,i \in set}}}
#' where \eqn{n_{iter}} is the number of algorithm iterations,
#' \eqn{n_{x \in set}} represents the number of observations in `x` belonging
#' to the set, and
#' \eqn{n_{sample,i \in set}} is the number of elements of the i^th random
#' sample shared with the set of interest.
#' The random sampling method allows for estimation of confidence intervals of
#' OR either with the bias-corrected accelerated (BCA) method or a simple 95^th
#' percentile range.
#'
#' Independently of the enrichment test type, zero-division may occur during
#' calculation of OR. To avoid it, the function allows for specifying of a
#' \href{https://en.wikipedia.org/wiki/Additive_smoothing}{Laplace smoother}.
#'
#' @return
#' a numeric matrix or a data frame with the following columns:
#'
#' * `entry_name`: name of the entry of the dictionary of sets, i.e. set name
#' (only for data frame output)
#'
#' * `n_entry`: numbers of all available features belonging to the set
#'
#' * `n_x_total`: the total number of elements in vector `x`
#'
#' * `n_intersect`: numbers of elements of `x` belonging to the set
#'
#' * `or`: odds ratio
#'
#' * `lower_ci` and `upper_ci`: lower and upper bound of confidence (only for
#' random sampling)
#'
#' * `iter_number`, `h0_number`, and `h1_number`: available only for the
#' random sampling algorithm; total number of successful iterations, numbers of
#' iterations in favor of the null hypothesis H0, and numbers of iterations in
#' favor of the alternative hypothesis H1
#'
#' * `p_value` and, optionally, `p_adjusted`: p values and p values adjusted for
#' multiple testing.
#'
#' @param x a character vector for which enrichment will be investigated, e.g.
#' a vector of identifiers of significantly regulated genes.
#' @param dict dictionary of sets. A named list of character vectors, where each
#' list element represents a feature set.
#' @param all a character vector of all investigated features. If `NULL`, those
#' features will be inferred from `dict`.
#' @param type type of enrichment test as described in details. Fisher's exact
#' test by default. Note that the random sampling method is considerably slower.
#' @param laplace Laplace smoother.
#' @param ci_type type of confidence intervals: BCA (default) or percentile.
#' Ignored for Fisher's tests.
#' @param conf_level confidence level used for computation of the confidence
#' intervals. Ignored for Fisher's tests.
#' @param as_data_frame should the output be formatted as a data frame? This may
#' render the computation slower.
#' @param adj_method multiple testing adjustment method, as specified for
#' \code{\link[stats]{p.adjust}}.
#' @param n_iter number of the algorithm's iterations. Ignored for Fisher's
#' tests.
#' @param .parallel logical, should the analysis be run in parallel? At the
#' moment, only the R-side parallelization via \code{\link[furrr]{future_map}}
#' is implemented. This option is available only for `type = 'random'`.
#' @param .n_chunks number of chunks of `dict` passed to parallel workers.
#' If `.n_chunks = NULL`, the number of chunks will be set to the umber of
#' available cores minus 1.
#' @param ... extra arguments, currently none specified.
#'
#' @export

  f_enrichment <- function(x, ...) UseMethod('f_enrichment')

#' @rdname f_enrichment
#' @export

  f_enrichment.default <- function(x,
                                   dict,
                                   all = NULL,
                                   type = c('fisher', 'random'),
                                   laplace = 1,
                                   ci_type = c('bca', 'percentile'),
                                   conf_level = 0.95,
                                   as_data_frame = FALSE,
                                   n_iter = 1000,
                                   adj_method = 'none',
                                   .parallel = FALSE,
                                   .n_chunks = NULL, ...) {

    ## input control for the x vector and dictionary --------

    stopifnot(is.atomic(x))

    if(!is.character(x)) x <- as.character(x)

    x <- x[!is.na(x)]
    x <- unique(x)

    if(length(x) < 2) {

      stop("At least two unique non-NA elements of 'x' are required.",
           call. = FALSE)

    }

    err_txt <- "'dict' has to be a list of character vetors."

    if(!is.list(dict)) stop(err_txt, call. = FALSE)

    dict <- compact(dict)

    stopifnot(length(dict) > 1)

    classes <- map_lgl(dict, is.character)

    if(any(!classes)) stop(err_txt, call. = FALSE)

    ## input control for the all vector ------

    if(is.null(all)) all <- unique(unname(unlist(dict)))

    if(!all(x %in% all)) {

      stop("All elements of 'x' must be present in 'all'.",
           call. = FALSE)

    }

    ## input control for the remaining arguments -------

    type <- match.arg(type[1], c('fisher', 'random'))

    stopifnot(is.numeric(laplace))

    ci_type <- match.arg(ci_type[1], c('bca', 'percentile'))

    stopifnot(is.numeric(conf_level))

    if(conf_level < 0 | conf_level > 1) {

      stop("'conf_level' must be within the [0, 1] range.", call. = FALSE)

    }

    stopifnot(is.logical(as_data_frame))
    stopifnot(is.numeric(n_iter))
    stopifnot(n_iter > 1)

    n_iter <- as.integer(n_iter)

    stopifnot(is.character(adj_method))

    ## enrichment testing --------

    on.exit(plan('sequential'))

    if(type == 'fisher') {

      result <- setFisher(x, all, dict, laplace)

      if(adj_method != 'none') {

        result <- cbind(result,
                        p_adjusted = p.adjust(result[, 5],
                                              method = adj_method))

      }

    } else {

      if(!.parallel) {

        result <-
          setEnrichment(x, all, dict, ci_type, conf_level, n_iter, laplace)

      } else {

        plan('multisession')

        if(is.null(.n_chunks)) .n_chunks <- availableCores() - 1

        dict_chunks <- chunk(dict, .n_chunks)

        result <- future_map(dict_chunks,
                             ~setEnrichment(x,
                                            all = all,
                                            dict = .x,
                                            ci_type = ci_type,
                                            conf_level = conf_level,
                                            n_iter = n_iter,
                                            laplace = laplace),
                             .options = furrr_options(seed = TRUE))

        result <- do.call('rbind', result)

      }

      if(adj_method != 'none') {

        result <- cbind(result,
                        p_adjusted = p.adjust(result[, 10],
                                              method = adj_method))

      }

    }

    rownames(result) <- names(dict)

    if(!as_data_frame) return(result)

    result <- as.data.frame(result)

    rownames_to_column(result, 'entry_name')

  }

# END -------
